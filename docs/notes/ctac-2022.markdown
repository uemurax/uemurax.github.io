---
layout: default
---

# 「正しい」圏論

この文書は[圏論 Advent Calendar 2022](https://adventar.org/calendars/7888)の17日目の記事です。

## 概要

「正しい」圏の定義を紹介します。主に [(Ahrens et al., 2015)](#aks2015) と [(HoTT Book)](#hottbook) の9章の内容です。

## はじめに

まずは圏の定義を確認しましょう。圏 `C` とは次の要素からなる構造です。

*   対象のなす集合 `Object C`
*   対象 `x : Object C` と `y : Object C` に対し、射のなす集合 `Map C x y`
*   恒等射、合成、単位律、結合律

この定義は「正しい」でしょうか。もちろん正しいのですが、少し微妙な点があります。それは圏がどう**同一視**されるかです。圏に対しては少なくとも4つの同一視の概念が考えられます。

1.  メタ理論における標準的な同一視の概念 (例えば集合論では集合としての等しさ)
2.  代数構造としての同型 (圏同型)
3.  圏同値 (合成が恒等関手と自然同型という意味で逆関手を持つ)
4.  弱圏同値 (充満忠実かつ本質的全射)

流石に集合としての等しさを論じることはないと思いますが、圏同型はしばしば登場します。群同型、環同型などから類推できる自然な概念です。しかし、「正しい」圏の同一視のしかたはもちろん圏同値です。圏同値と弱圏同値はもちろん同値ですが、それはあくまで定理なのでいったん区別しておきます。同一視の概念が複数あるのは非常に煩わしいことです。2-圏論とか。

もう一つ微妙な点があります。圏同値と弱圏同値の同値性を示すには**選択公理**を使います。これは同型を除いて一意な対象を選択する必要があるからです。しかし、同型を除いてとはいえ**一意**な対象を選択するというは不自然な話です。また、具体的な圏同値を思い浮かべると、本質的全射の証明では具体的な**構成**が与えられることがほとんどです。圏論に選択公理が要るはずがありません。

この文書では、上に挙げた4つの圏の同一視の概念が**すべて同値**になるような圏の定義を紹介します。また、その同値性は**構成的**に証明されます。もちろん選択公理は要りません。

## メタ理論: Univalent Foundations

この文書では **Univalent Foundations** [(HoTT Book)](#hottbook) をメタ理論として採用します。これは筆者の趣味というだけでなくこの文書において本質的です。というのも、例えば (公理的または素朴) 集合論においては圏同型と圏同値はそもそも同値ではありません。もっと言えば集合としての等しさと代数構造としての同型が同値になることはほぼありません。集合としての等しさは常に**命題**であり、要素を高々1つしか持たない集合と考えられます。一方、代数構造としての同型は複数ありえます。この2つの概念を同値とみなすことを正当化することは等しさが常に命題であるようなメタ理論を採用する限り難しいと言えます。

### 型

Univalent Foundations は Martin-Löf の**依存型理論** [(Martin-Löf, 1975)](#ml1975) をベースとします。このメタ理論では数学は**型**やその**要素**を**構成**することで営まれます。命題という概念は組み込まれていません。型とは素朴な意味で集合に近い概念で、その要素は集合の要素のようなものです。 `A` が型であることは `A : Type` と書き、 `a` が型 `A` の要素であることは `a : A` と書きます。型 `A` に対し、　**`A` 上の依存型**は `A` で添え字付けられた集合族のようなもので、 `B : A -> Type` のように書きます。

### 同一視の型

型 `A` とその要素 `a : A` と `b : A` に対し、**同一視の型 (identity type)** `a = b` が構成できます。もともとの気持ちは `a` と `b` が等しいという命題だったのですが、 Univalent Foundations の文脈では `a = b` の要素は `a` と `b` の**同一視のしかた**と考えます。普通の等式と違って **`a = b` は複数の異なる要素を持ちえます**。普通の等式と同様に、**あらゆる構成は同一視を保ちます**。例えば関数 `f : A -> B` と `a : A` と `b : A` に対し、関数 `ap f : a = b -> f a = f b` が誘導されます。

### その他の型

すでに言及しましたが、型 `A` と `B` に対して、**関数型** `A -> B` が構成できて、その要素は関数です。もっと一般に、依存型 `B : A -> Type` に対して、**依存関数型** `(x : A) -> B x` が構成できて、その要素は `x : A` に対して `B x` の要素を返す関数です。返り値の型が引数に依存するのでこのような関数は依存関数と呼ばれます。

型 `A` と `B` に対して、**対の型** `A * B` が構成できて、その要素は `a : A` と `b : B` の対 `(a, b)` です。もっと一般に、依存型 `B : A -> Type` に対して、**依存対の型** `(x : A) * B x` が構成できて、その要素は `a : A` と `b : B a` の対 `(a, b)` です。2番目の要素の型が1番目の要素に依存するのでこのような対は依存対と呼ばれます。

### Truncation level

型 `A` に対して、型 `Contractible A` を `(a : A) * ((x : A) -> a = x)` と定義します。これは要素 `a : A` があって他のすべての要素 `x : A` は `a` と同一視されることを表します。つまり、 `A` はただ一つの要素を持つということです。 Contractible (可縮) という用語はホモトピー論から来ます。

`n : {-2, -1, 0, ...}` に対して、型 `Truncated n A` を帰納的に `Truncated (-2) A := Contractible A` と `Truncated (n + 1) A := (x, y : A) -> Truncated n (x = y)` で定義します。例えば、 `Truncated (-1) A := (x, y : A) -> Contractible (x = y)` は任意の `x, y : A` に対して、ただ一つの `x` と `y` の同一視のしかたがあるとういこと、つまり `A` の要素は高々一つであることを表します。 `Truncated (-1) A` の要素がある時 `A` は従来の命題のようにふるまうため、 `IsProposition A := Truncated (-1) A` と書くこともあります。 `Truncated 0 A := (x, y : A) -> IsProposition (x = y)` は　`A` の要素の同一視の型 `x = y` が命題であること、つまり `A` は従来の集合のようにふるまうことを表します。そのため、 `IsSet A := Truncated 0 A` と書くこともあります。

### 型の同値

関数 `f : A -> B` に対して、型 `IsEquivalence f` を `(y : B) -> IsContractible ((x : A) * (f x = y))` と定義します。 `(x : A) * (f x = y)` の部分は `y` の `f` による逆像と読めるので、 `IsEquivalence f` は任意の `y : B` に対して `y` の `f` による逆像がただ一つの要素を持つことを表します。型 `A ≃ B` を `(f : A -> B) * IsEquivalence f` と定義します。

### Univalence

`A : Type` と `a : A` を同じ記法で書いていますが、これは `Type` という記号は要素が型であるような型であるということです。正確には、 `Type` 自身が `Type` の要素であると矛盾が起こる (Girard のパラドックス) ので、 `Type 0 : Type 1 : Type 2 : ...` のように階層付けられています。単に `Type` と書いた時はいい感じに階数が補完されていると考えます。

さて、 `Type` が型ということは `A, B : Type` に対して同一視の型 `A = B` が構成できます。一方、 `A ≃ B` も自然な型の同一視の概念です。恒等関数は同値であることが示せるので、関数
```
id-to-equiv A B : A = B -> A ≃ B
```
を構成できます。 **Univalence Axiom** は `id-to-equiv A B` が同値であることを要請します。つまり、
```
univalence A B : IsEquivalence (id-to-equiv A B)
```
を構成できます。

## 「正しい」圏の定義

Univalent Foundations で圏を定義します。素朴な定義は次のようになるでしょう。 **Wild category** を次の要素からなる構造 `C` であると定義します。

*   `Object C : Type`
*   `Map C : Object C -> Object C -> Type`
*   `identity C : (x : Object C) -> Map C x x`
*   `compose C : {x, y, z : Object C} -> Map C y z -> Map C x y -> Map C x z`
*   `unit-left C : (x, y : Object C) (f : Map C x y) -> compose C (identity C y) f = f`
*   `unit-right C : (x, y : Object C) (f : Map C x y) -> compose C f (identity C x) = f`
*   `associativity C : (x y z w : Object C) (h : Map C z w) (g : Map C y z) (f : Map C x y) -> compose C (compose C h g) f = compose C h (compose C g h)`

`compose C` の型において波括弧 `{}` の中に書いた引数は他の引数の型から分かるので関数適用の際には省略しています。さて、 Univalent Foundations において注意すべきことは `a = b` は型であって複数の異なる要素を持ち得ることでした。となると、 `unit-left C` と `unit-right C` と `associativity C` は公理というよりは**構造の一部**であると考えられます。高次元圏論で見られるように、この手の構造がよくふるまうためには **coherence** も公理または構造として含める必要があるでしょう。この文書では普通の圏を考えているのでこの方面への深入りは避けます。

普通の圏は Set-豊穣圏ですので、 `Map C` が集合に値をとるように制限するのが自然です。 Wild category `C` であって
```
(x, y : Object) -> IsSet (Map C x y)
```
の要素を持つようなものを**前圏 (precategory)** と呼びます。まだ圏ではありません。前圏 `C` に対しては、 `unit-left C` と `unit-right C` と `associativity C` は公理のようにふるまうので、 coherence は要りません。 `Object C` の truncation level を制限する必要性は見えないので特に条件は課しません。

さて、そもそもなぜ圏同型と圏同値に差があるかと考えると、圏の対象の同一視の概念が

*   メタ理論における標準的な同一視の概念
*   同型

の2種類あるからです。これは Univalent Foundations において前圏を上のように定義したところで同じことです。「正しい」圏の定義を得るには**この2つの同一視の概念が同値になる**ような条件を課すのが良いでしょう。

前圏 `C` とその対象 `x, y : Object C` に対して、**同型射の型** `x ≅ y` は自然に定義されます。恒等射は同型射なので、関数
```
id-to-iso C x y : x = y -> x ≅ y
```
が構成できます。**圏**とは前圏 `C` であって
```
(x, y : Object C) -> IsEquivalence (id-to-iso C x y)
```
の要素を持つものと定義します。 Univalence Axiom と似たパターンなので、この条件は **univalence** と呼ばれます。また、(∞, 1)-圏のモデルの一つである complete Segal space [(Rezk, 2001)](#rezk2001) に類似の条件が課されるので、その提唱者に因んで **Rezk 条件** とも呼ばれます。

## 参考文献

*   <span id="aks2015"></span>
    Benedikt Ahrens, Krzysztof Kapulkin, and Michael Shulman.
    "Univalent categories and the Rezk completion."
    Mathematical Structures in Computer Science 25.5 (2015): 1010-1039.
    [doi:10.1017/S0960129514000486](https://doi.org/10.1017/S0960129514000486)
    [arXiv:1303.0584](https://arxiv.org/abs/1303.0584)
*   <span id="hottbook"></span>
    The Univalent Foundations Program.
    "Homotopy Type Theory: Univalent Foundations of Mathematics."
    Institute for Advanced Study, 2013.
    <https://homotopytypetheory.org/book/>
*   <span id="ml1975"></span>
    Per Martin-Löf.
    "An intuitionistic theory of types: Predicative part."
    Studies in Logic and the Foundations of Mathematics. Vol. 80. Elsevier, 1975. 73-118.
    [doi:10.1016/S0049-237X(08)71945-1](https://doi.org/10.1016/S0049-237X(08)71945-1)
*   <span id="rezk2001"></span>
    Charles Rezk.
    "A model for the homotopy theory of homotopy theory."
    Transactions of the American Mathematical Society 353.3 (2001): 973-1007.
    [doi:10.1090/S0002-9947-00-02653-2](https://doi.org/10.1090/S0002-9947-00-02653-2)
    [arXiv:math/9811037](https://arxiv.org/abs/math/9811037)
